<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>git常用命令和错误排除</title>
      <link href="/git-command-notes.html"/>
      <url>/git-command-notes.html</url>
      
        <content type="html"><![CDATA[<h3 id="git-clone错误"><a href="#git-clone错误" class="headerlink" title="git clone错误"></a>git clone错误</h3><h4 id="SSL证书错误"><a href="#SSL证书错误" class="headerlink" title="SSL证书错误"></a>SSL证书错误</h4><pre><code>git clone https://github.com/maclxf/supermall.git</code></pre><p>报错：</p><pre><code>Cloning into &#39;supermall&#39;...fatal: unable to access &#39;https://github.com/maclxf/supermall.git/&#39;: OpenSSL SSL_read: Connection was reset, errno 10054</code></pre><p>这是服务器的SSL证书，没有经过第三方签名，所以报错。</p><p>如果是由网络不稳定和连接超时引起的。再次尝试的话，您仍然会报告一个错误。</p><p>解决方式如下：</p><pre><code>git config --global http.sslVerify &quot;false&quot;git init</code></pre><p>会看到如下结果</p><pre><code>Initialized empty Git repository in D:/Users/HP/Desktop/Projects/.git/</code></pre><p>重新clone</p><pre><code>git clone https://github.com/maclxf/supermall.git</code></pre><p>成功！</p><pre><code>Cloning into &#39;supermall&#39;...remote: Enumerating objects: 200, done.remote: Counting objects: 100% (200/200), done.remote: Compressing objects: 100% (152/152), done.Receiving objects:  88% (176/200)ote: Total 200 (delta 68), reused 139 (delta 27), pack-reused 0Receiving objects: 100% (200/200), 198.04 KiB | 594.00 KiB/s, done.Resolving deltas: 100% (68/68), done.</code></pre><h4 id="Time-Out"><a href="#Time-Out" class="headerlink" title="Time Out"></a>Time Out</h4><pre><code>git clone https://github.com/1977474741/vue-waterfall-rapid.git</code></pre><p>报错:</p><pre><code>Cloning into &#39;vue-waterfall-rapid&#39;...fatal: unable to access &#39;https://github.com/1977474741/vue-waterfall-rapid.git/&#39;: Failed to connect to github.com port 443: Timed out</code></pre><p>解决方式：找到C:\Windows\System32\drivers\etc\hosts文件，把与github有关的行注释掉即可。</p><p><img src="/git-command-notes/1.png" alt></p><p><img src="/git-command-notes/2.png" alt></p><p>取消代理设置</p><pre><code>git config --global --unset http.proxy</code></pre><p>再进行clone</p><pre><code>git clone https://github.com/itagn/vue-iresume.git</code></pre><pre><code>Cloning into &#39;vue-iresume&#39;...remote: Enumerating objects: 455, done.remote: Total 455 (delta 0), reused 0 (delta 0), pack-reused 455Receiving objects: 100% (455/455), 367.11 KiB | 402.00 KiB/s, done.Resolving deltas: 100% (192/192), done.</code></pre><p>问题解决！</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ajax学习笔记</title>
      <link href="/6-ajaxnotes.html"/>
      <url>/6-ajaxnotes.html</url>
      
        <content type="html"><![CDATA[<h1 id="Node环境部署"><a href="#Node环境部署" class="headerlink" title="Node环境部署"></a>Node环境部署</h1><h3 id="安装express后端框架"><a href="#安装express后端框架" class="headerlink" title="安装express后端框架"></a>安装express后端框架</h3><pre><code>npm install express</code></pre><pre><code>npm WARN saveError ENOENT: no such file or directory, open &#39;D:\Users\HP\Desktop\tech\前端开发\AjaxLearn\package.json&#39;npm WARN enoent ENOENT: no such file or directory, open &#39;D:\Users\HP\Desktop\tech\前端开发\AjaxLearn\package.json&#39;npm WARN AjaxLearn No descriptionnpm WARN AjaxLearn No repository field.npm WARN AjaxLearn No README datanpm WARN AjaxLearn No license field.+ express@4.17.1added 50 packages from 37 contributors in 2.194s</code></pre><h3 id="安装nodemon包"><a href="#安装nodemon包" class="headerlink" title="安装nodemon包"></a>安装nodemon包</h3><pre><code>npm install -g nodemon</code></pre><pre><code>D:\nodejs\nodemon -&gt; D:\nodejs\node_modules\nodemon\bin\nodemon.js&gt; nodemon@2.0.15 postinstall D:\nodejs\node_modules\nodemon&gt; node bin/postinstall || exit 0npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@~2.3.2 (node_modules\nodemon\node_modules\chokidar\node_modules\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@2.3.2: wanted {&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;} (current: {&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;})+ nodemon@2.0.15added 116 packages from 53 contributors in 4.331s(base) PS D:\Users\HP\Desktop\tech\前端开发\AjaxLearn&gt; nodemon  Usage: nodemon [nodemon options] [script.js] [args]  See &quot;nodemon --help&quot; for more.</code></pre><p>安装这个包是为了可以让服务端的代码改变之后，按Ctrl+s可以自动重启服务。</p><h3 id="运行express"><a href="#运行express" class="headerlink" title="运行express"></a>运行express</h3><p>在服务端的路径之下运行此服务端。</p><pre><code>nodemon server.js</code></pre><pre><code>[nodemon] 2.0.15[nodemon] to restart at any time, enter `rs`[nodemon] watching path(s): *.*[nodemon] watching extensions: js,mjs,json[nodemon] starting `node server.js`服务以及启动，8090  端口监听中</code></pre><p><strong>server.js文件*</strong></p><pre><code>// 导入express模块const express = require(&#39;express&#39;);const app = express();app.get(&#39;/&#39;, (request, response) =&gt; {    // 设置响应    response.send(&#39;HELLO EXPRESS&#39;)});// 可以接受任何类型的请求app.all(&#39;/server&#39;, (request, response) =&gt; {    // 设置响应头，设置允许跨域    response.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;);    //响应头    response.setHeader(&#39;Access-Control-Allow-Headers&#39;, &#39;*&#39;)        // 设置响应体    response.send(&#39;HELLO AJAX POST&#39;)});app.listen(8090, () =&gt; {    console.log(&quot;服务以及启动，8090  端口监听中&quot;)})</code></pre><p>在浏览器的url中输入</p><pre><code>localhost:8090</code></pre><p>可以看到后端服务已经可以开始运行了。</p><p><img src="/6-ajaxnotes/express.png" alt></p><h1 id="发送Ajax请求"><a href="#发送Ajax请求" class="headerlink" title="发送Ajax请求"></a>发送Ajax请求</h1><h3 id="发送GET请求"><a href="#发送GET请求" class="headerlink" title="发送GET请求"></a>发送GET请求</h3><pre class="line-numbers language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>X-UA-Compatible<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>IE<span class="token punctuation">=</span>edge<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width<span class="token punctuation">=</span>device-width, initial-scale<span class="token punctuation">=</span>1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Document<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">></span></span><span class="token style language-css">        <span class="token selector"><span class="token id">#result</span> </span><span class="token punctuation">{</span>            <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">200</span>px<span class="token punctuation">;</span>            <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">100</span>px<span class="token punctuation">;</span>            <span class="token property">border</span><span class="token punctuation">:</span> solid <span class="token number">1</span>px <span class="token hexcode">#90b</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>点击发送请求<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>result<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">        <span class="token keyword">const</span> btn <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        btn<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 创建对象</span>            <span class="token keyword">const</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">const</span> result <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"result"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 设置请求方法和url</span>            xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'GET'</span><span class="token punctuation">,</span> <span class="token string">'http://localhost:8090/server?a=100&amp;b=200&amp;c=300'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 发送</span>            xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 事件绑定</span>            <span class="token comment" spellcheck="true">// on 当---时候</span>            <span class="token comment" spellcheck="true">// readystate 是 xhr 对象的属性 表示状态0（初始化） 1（open） 2（send） 3（部分结果） 4（全部结果）</span>            <span class="token comment" spellcheck="true">// change 改变</span>            xhr<span class="token punctuation">.</span>onreadystatechange <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 判断服务端是否返回了所有结果</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 判断相应装填码200 404 403 401 500</span>                    <span class="token comment" spellcheck="true">// 2开头一般都表示成功</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status <span class="token operator">>=</span> <span class="token number">200</span> <span class="token operator">&amp;&amp;</span> xhr<span class="token punctuation">.</span>status <span class="token operator">&lt;</span> <span class="token number">300</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// 处理结果 行 头 空行 体</span>                        <span class="token comment" spellcheck="true">// 1.相应行</span>                        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// GET.html: 42 200</span>                        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>statusText<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// GET.html: 43 OK</span>                        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>getAllResponseHeaders<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// GET.html: 44 ƒ getAllResponseHeaders() { [native code] }</span>                        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// GET.html: 45 HELLO AJAX</span>                        result<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> xhr<span class="token punctuation">.</span>response                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"测试失败"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Test'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>前端展示页面如下图所示</p><p><img src="/6-ajaxnotes/1.png" alt></p><p>点击按钮可以看到请求发送成功</p><p><img src="/6-ajaxnotes/2.png" alt></p><p>利用浏览器开发者工具，点击网络按钮，就可以看到具体的网路请求信息。</p><p><img src="/6-ajaxnotes/3.png" alt></p><p><img src="/6-ajaxnotes/4.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> Ajax </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构走迷宫</title>
      <link href="/5.html"/>
      <url>/5.html</url>
      
        <content type="html"><![CDATA[<h1 id="VSCode文件配置"><a href="#VSCode文件配置" class="headerlink" title="VSCode文件配置"></a>VSCode文件配置</h1><h3 id="c-cpp-properties-json"><a href="#c-cpp-properties-json" class="headerlink" title="c_cpp_properties.json"></a>c_cpp_properties.json</h3><pre><code>{    &quot;configurations&quot;: [        {            &quot;name&quot;: &quot;Win32&quot;,            &quot;compilerPath&quot;: &quot;D:/mingw64/bin/g++.exe&quot;, //这里改成自己的路径            &quot;includePath&quot;: [                &quot;${workspaceFolder}/**&quot;,                // 这里添加自己的OpenCV路径                &quot;D:/mingw64/include&quot;,                &quot;D:/OpenCV/opencv_build_cmake/install/include&quot;,                &quot;D:/OpenCV/opencv_build_cmake/install/include/opencv2&quot;            ],            &quot;defines&quot;: [                &quot;_DEBUG&quot;,                &quot;UNICODE&quot;,                &quot;_UNICODE&quot;            ],            &quot;cStandard&quot;: &quot;c11&quot;,            &quot;cppStandard&quot;: &quot;c++17&quot;,            &quot;intelliSenseMode&quot;: &quot;clang-x64&quot;        }    ],    &quot;version&quot;: 4}</code></pre><h3 id="launch-json"><a href="#launch-json" class="headerlink" title="launch.json"></a>launch.json</h3><pre><code>// https://code.visualstudio.com/docs/cpp/launch-json-reference{    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [    {        &quot;name&quot;: &quot;(gdb) Launch&quot;, // 配置名称，将会在启动配置的下拉菜单中显示        &quot;type&quot;: &quot;cppdbg&quot;, // 配置类型，cppdbg对应cpptools提供的调试功能；可以认为此处只能是cppdbg        &quot;request&quot;: &quot;launch&quot;, // 请求配置类型，可以为launch（启动）或attach（附加）        &quot;program&quot;: &quot;${fileDirname}/${fileBasenameNoExtension}.exe&quot;, // 将要进行调试的程序的路径        &quot;args&quot;: [], // 程序调试时传递给程序的命令行参数，一般设为空即可        &quot;stopAtEntry&quot;: false, // 设为true时程序将暂停在程序入口处，相当于在main上打断点        &quot;cwd&quot;: &quot;${workspaceFolder}&quot;, // 调试程序时的工作目录，此为工作区文件夹；改成${fileDirname}可变为文件所在目录        &quot;environment&quot;: [], // 环境变量        &quot;externalConsole&quot;: true, // 使用单独的cmd窗口，与其它IDE一致；为false时使用内置终端        &quot;internalConsoleOptions&quot;: &quot;neverOpen&quot;, // 如果不设为neverOpen，调试时会跳到“调试控制台”选项卡，你应该不需要对gdb手动输命令吧？        &quot;MIMode&quot;: &quot;gdb&quot;, // 指定连接的调试器，可以为gdb或lldb。        &quot;miDebuggerPath&quot;: &quot;D:/mingw64/bin/gdb.exe&quot;, // 调试器路径，Windows下后缀不能省略，Linux下则不要        &quot;setupCommands&quot;: [            { // 模板自带，好像可以更好地显示STL容器的内容，具体作用自行Google                &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,                &quot;text&quot;: &quot;-enable-pretty-printing&quot;,                &quot;ignoreFailures&quot;: false            }        ],        &quot;preLaunchTask&quot;: &quot;Compile&quot; // 调试会话开始前执行的任务，一般为编译程序。与tasks.json的label相对应    }]}</code></pre><h3 id="tasks-json"><a href="#tasks-json" class="headerlink" title="tasks.json"></a>tasks.json</h3><pre><code>// https://code.visualstudio.com/docs/editor/tasks{    &quot;version&quot;: &quot;2.0.0&quot;,    &quot;tasks&quot;: [        {        &quot;label&quot;: &quot;Compile&quot;, // 任务名称，与launch.json的preLaunchTask相对应        &quot;command&quot;: &quot;D:/mingw64/bin/g++.exe&quot;,   // 要使用的编译器，C++用g++        &quot;args&quot;: [            &quot;${file}&quot;,//当前文件名            &quot;-o&quot;,    // 指定输出文件名，不加该参数则默认输出a.exe，Linux下默认a.out            &quot;${fileDirname}/${fileBasenameNoExtension}.exe&quot;,            &quot;-g&quot;,    // 生成和调试有关的信息            &quot;-m64&quot;, // 不知为何有时会生成16位应用而无法运行，加上此条可强制生成64位的            &quot;-Wall&quot;, // 开启额外警告            &quot;-static-libgcc&quot;,     // 静态链接libgcc，一般都会加上            &quot;-finput-charset=UTF-8&quot;,            &quot;-fexec-charset=GBK&quot;, // 生成的程序使用GBK编码，不加这条会导致Win下输出中文乱码；繁体系统改成BIG5            &quot;-std=c++17&quot;, // 要用的语言标准，根据自己的需要修改。c++可用c++14            // 扩展参数            // -I 头文件目录            // -L 库文件目录            // -l 库文件            // 这里换成自己的文件路径            &quot;-I&quot;, &quot;D:/OpenCV/opencv_build_cmake/install/include&quot;,            &quot;-I&quot;, &quot;D:/OpenCV/opencv_build_cmake/install/include/opencv2&quot;,            &quot;-L&quot;, &quot;D:/OpenCV/opencv_build_cmake/install/x64/mingw/lib&quot;,            &quot;-l&quot;, &quot;libopencv_calib3d420&quot;,            &quot;-l&quot;, &quot;libopencv_core420&quot;,            &quot;-l&quot;, &quot;libopencv_dnn420&quot;,            &quot;-l&quot;, &quot;libopencv_features2d420&quot;,            &quot;-l&quot;, &quot;libopencv_flann420&quot;,            &quot;-l&quot;, &quot;libopencv_highgui420&quot;,            &quot;-l&quot;, &quot;libopencv_imgcodecs420&quot;,            &quot;-l&quot;, &quot;libopencv_imgproc420&quot;,            &quot;-l&quot;, &quot;libopencv_ml420&quot;,            &quot;-l&quot;, &quot;libopencv_objdetect420&quot;,            &quot;-l&quot;, &quot;libopencv_photo420&quot;,            &quot;-l&quot;, &quot;libopencv_stitching420&quot;,            &quot;-l&quot;, &quot;libopencv_video420&quot;,            &quot;-l&quot;, &quot;libopencv_videoio420&quot;,            &quot;-l&quot;, &quot;opencv_core420&quot;,            &quot;-l&quot;, &quot;opencv_imgproc420&quot;,            &quot;-l&quot;, &quot;opencv_imgcodecs420&quot;,            &quot;-l&quot;, &quot;opencv_video420&quot;,            &quot;-l&quot;, &quot;opencv_ml420&quot;,            &quot;-l&quot;, &quot;opencv_highgui420&quot;,            &quot;-l&quot;, &quot;opencv_objdetect420&quot;,            &quot;-l&quot;, &quot;opencv_flann420&quot;,            &quot;-l&quot;, &quot;opencv_imgcodecs420&quot;,            &quot;-l&quot;, &quot;opencv_photo420&quot;,            &quot;-l&quot;, &quot;opencv_videoio420&quot;,            // 中文编码            // &quot;-finput-charset=GBK&quot;            ], // 编译的命令，其实相当于VSC帮你在终端中输了这些东西        &quot;type&quot;: &quot;process&quot;, // process是把预定义变量和转义解析后直接全部传给command；shell相当于先打开shell再输入命令，所以args还会经过shell再解析一遍        &quot;group&quot;: {            &quot;kind&quot;: &quot;build&quot;,            &quot;isDefault&quot;: true // 不为true时ctrl shift B就要手动选择了        },        &quot;presentation&quot;: {            &quot;echo&quot;: true,            &quot;reveal&quot;: &quot;always&quot;, // 执行任务时是否跳转到终端面板，可以为always，silent，never。具体参见VSC的文档            &quot;focus&quot;: false,     // 设为true后可以使执行task时焦点聚集在终端，但对编译C/C++来说，设为true没有意义            &quot;panel&quot;: &quot;shared&quot;   // 不同的文件的编译信息共享一个终端面板        },        &quot;problemMatcher&quot;:&quot;$gcc&quot; // 捕捉编译时终端里的报错信息到问题面板中，修改代码后需要重新编译才会再次触发        // 本来有Lint，再开problemMatcher就有双重报错，但MinGW的Lint效果实在太差了；用Clang可以注释掉    }],}</code></pre><h1 id="迷宫算法"><a href="#迷宫算法" class="headerlink" title="迷宫算法"></a>迷宫算法</h1><pre><code>#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;unistd.h&gt;#include&lt;time.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;sys/timeb.h&gt;#include&lt;Windows.h&gt;#include&lt;opencv.hpp&gt;#include&lt;opencv2/opencv.hpp&gt;#include &lt;opencv2/highgui/highgui.hpp&gt;#define IN_MAXSIZE 100#define INCREASE 10#define SElemType Single_Point #define FALSE 0#define TURE 1#define a 0     //a表示路 #define b 1        //b表示墙 using std::random_shuffle;using namespace cv;typedef struct {    int x;    //行坐标     int y;      //列坐标     int direction = 1;     //方向}SElemType;typedef struct{    SElemType *base;    SElemType *top;    int stacksize;}SqStack;const int n = 121;const int k = n / 2;const int N = k * k;// 迷宫的大小 n * nint Init_Stack(SqStack *);     int Push(SqStack *,SElemType);         int Pop(SqStack *,SElemType *);  int* randperm(int limit);void DFSmaze(SElemType [],int [][n],int [][k]); void PrintMaze(int maze[][n]);void draw(int x,int y,int flag);bool MazePath(int maze[][n], SElemType start, SElemType end);int Pass(SElemType pos);bool StackEmpty(SqStack S);void NextPos(SElemType* curpos, int direction);void MakePrint(SElemType e, int print);void PrintPath(SqStack *);const int limit = 4; const int node_size = 6;const int sleep_time = 5;const int wait_key = 3;int* choices;int maze[n][n];struct timeb seed;// 长度 宽度 CV通道数Mat mat(node_size * n, node_size * n, CV_8UC3);int main(){    ftime(&amp;seed);    srand(seed.time * 1000 + seed.millitm);    choices = (int*)malloc(limit * sizeof(int));    choices = randperm(limit);    int i,j;    int smaze[k][k];    // 结构体数组     SElemType r[(k)*(k)];       // 把所有点都先初始化为墙。    for(i=0;i&lt;n;i++)        for(j=0;j&lt;n;j++)        {            maze[i][j] = b;        }    // 先使得横坐标和纵坐标都为偶数的变为路。    for(i=1;i&lt;n-1;i=i+2)        for(j=1;j&lt;n-1;j=j+2)        {            maze[i][j] = a;        }    // 定义起始点和结束点。    maze[1][0]=a;        maze[n-2][n-1]=a;    // 存储结构体数组的横坐标和纵坐标。    for(i=0;i&lt;k*k;i++)   //结构体数组赋初值，索引从零开始    {        r[i].x = i/k;        r[i].y = i%k;    }    // 数组中所有的初值全部置为FALSE，表示这些位置都没有被访问。    for(i=0;i&lt;k;i++)         for(j=0;j&lt;k;j++)            smaze[i][j] = FALSE;    // DFS首先访问的节点。    smaze[0][0] = TURE;  // 初始节点     DFSmaze(r,maze,smaze);    PrintMaze(maze);     // 打印生成迷宫     namedWindow(&quot;Maze&quot;);    for (int i = 0; i &lt; n; i++)    {        for (int j = 0; j &lt; n; j++)        {            if (maze[i][j] == 1)            {                draw(i, j, 1);            }            else if(maze[i][j] == 0)            {                draw(i, j, 2);            }        }    }    imshow(&quot;Maze&quot;, mat);    waitKey(1000);    printf(&quot;Please enter 0 to continue.\n&quot;);    SElemType start, end;    start.x = 1; start.y = 0;    end.x = n - 2; end.y = n - 1;    MazePath(maze, start, end);    system(&quot;pause&quot;);    return 0;}void PrintPath(SqStack * s) {    int count = 0;    while (s-&gt;base &lt; s-&gt;top)    {        printf(&quot;(%d, %d)--&gt;&quot;, s-&gt;base-&gt;x, s-&gt;base-&gt;y);        count++; s-&gt;base++;        if (count % 8 == 0)            printf(&quot;\n&quot;);    }}void PrintMaze(int maze[][n]) {    for(int i=0;i&lt;n;i++)     // 打印生成迷宫     {            for(int j=0;j&lt;n;j++)        {            printf(&quot;%d &quot;,maze[i][j]);        }        printf(&quot;\n&quot;);    }}int Init_Stack(SqStack *t)     //初始栈 {    t-&gt;base = (SElemType *)malloc(IN_MAXSIZE*sizeof(SElemType));    if(!(t-&gt;base))        return 0;    t-&gt;top = t-&gt;base;    t-&gt;stacksize = IN_MAXSIZE;    return 1;   }int Push(SqStack *t,SElemType e)   //入栈 {    if(t-&gt;top-t-&gt;base&gt;=t-&gt;stacksize)        {        t-&gt;base = (SElemType *)realloc(t-&gt;base,(t-&gt;stacksize+INCREASE)*sizeof(SElemType));        if(!t-&gt;base)            return 0;        t-&gt;top = t-&gt;base + t-&gt;stacksize;            t-&gt;stacksize += INCREASE;     }    *(t-&gt;top++) = e;    return 1;  } int Pop(SqStack *t,SElemType *e)     //出栈 {    if(t-&gt;top==t-&gt;base)        return 0;    *e = *(--t-&gt;top);    return 1;}/*循环弹栈，弹出一个，则将其二维数组中的FALSE改为TURE表示该元素已经被访问了。然后寻找其上下左右没有被访问的元素，找到一个，则将夹在两个蓝色圈中的墙打破，使其变成路，然后找到的未访问的元素入栈。*/void DFSmaze(SElemType r[N],int maze[n][n],int smaze[k][k]) //深度优先算法 {    SElemType e;             // 结构体变量e    SqStack s;               // 栈里面的存储的为结构体    if(Init_Stack(&amp;s)==1)      // 初始栈         printf(&quot;OK\n&quot;);     else        printf(&quot;Fail\n&quot;);          Push(&amp;s,r[0]);  //压栈r[0]    printf(&quot;initializeing maze......\n&quot;);    while(Pop(&amp;s,&amp;e))  //栈不空时，进行循环     {        choices = randperm(limit);        for(int i=0;i&lt;limit;i++) {            switch(choices[i]) {                //0，1，2，3分别对应上右下左                case 0: {                    // 点不能为外墙并且该结点未被访问过                    if(e.x - 1 &gt;= 0 &amp;&amp; smaze[e.x-1][e.y]!=TURE) // 上                    {                        // 该节点的状态变成访问过。                        smaze[e.x-1][e.y] = TURE;                        maze[2*e.x][2*e.y+1] = a; //打墙                         // 这里面r是一个一维结构体数组，每个结构分别存储X坐标和Y坐标。                        Push(&amp;s,r[(e.x-1)*k+e.y]);                        }                     break;                }                case 1: {                    if(e.y + 1 &lt; k  &amp;&amp; smaze[e.x][e.y+1]!=TURE) // 右                     {                        smaze[e.x][e.y+1] = TURE;                              maze[2*e.x+1][2*(e.y+1)] = a;                            Push(&amp;s,r[(e.x)*k+e.y+1]);                        }                    break;                }                case 2: {                    if(e.x + 1 &lt; k &amp;&amp; smaze[e.x+1][e.y]!=TURE) // 下                    {                        smaze[e.x+1][e.y] = TURE;                        maze[2*(e.x+1)][2*e.y+1] = a;                         Push(&amp;s,r[(e.x+1)*k+e.y]);                        }                    break;                }                case 3: {                    if(e.y - 1 &gt;= 0 &amp;&amp; smaze[e.x][e.y-1]!=TURE) // 左                     {                        smaze[e.x][e.y-1] = TURE;                        maze[2*e.x+1][2*e.y] = a;                        Push(&amp;s,r[(e.x)*k+e.y-1]);                        }                    break;                }            }        }    } } int* randperm(int limit){    Sleep(sleep_time);    ftime(&amp;seed);    srand(seed.time * 1000 + seed.millitm);    int* numbers;    numbers = (int*)malloc(limit * sizeof(int));    for (int i = 0; i &lt; limit; i++)        numbers[i] = i;    random_shuffle(numbers, numbers + limit);    return numbers;}void draw(int x,int y,int flag){    int red, green, black;    if (flag == 1)    {        red = 0, green = 0, black = 0;    }    else if (flag == 2)    {        red = 0, green = 255, black = 255;    }    else if (flag == 3)    {        red = 255, green = 0, black = 0;    }    else if (flag == 4)    {        red = 0, green = 255, black = 0;    }    // 每个点像素为50?50    for (int i = x * node_size; i &lt; x * node_size + node_size; i++)    {        for (int j = y * node_size; j &lt; y * node_size + node_size; j++)        {            mat.at&lt;Vec3b&gt;(i, j)[0] = black;            mat.at&lt;Vec3b&gt;(i, j)[1] = green;            mat.at&lt;Vec3b&gt;(i, j)[2] = red;        }    }}bool MazePath(int maze[][n], SElemType start, SElemType end){    SqStack S;    // SElemType* e;    Init_Stack(&amp;S);      // 初始栈     SElemType curpos = start;    // 初始点变为红色    draw(start.x, start.y, 3);    imshow(&quot;Maze&quot;, mat);    waitKey(wait_key);    Push(&amp;S, start);    int direction;    int curstep = 1;    do {        if(Pass(curpos)) {            if(curpos.x == end.x &amp;&amp; curpos.y == end.y) {                PrintPath(&amp;S);                return true;            }            // 加入当前道路            MakePrint(curpos, 2);            NextPos(&amp;curpos, curpos.direction);            if(maze[curpos.x][curpos.y] != 0) {                curpos.direction = curpos.direction % 4 + 1;                continue;            }            Push(&amp;S, curpos);            draw(curpos.x, curpos.y, 3);            imshow(&quot;Maze&quot;, mat);            waitKey(wait_key);            if(curpos.x == end.x &amp;&amp; curpos.y == end.y) {                PrintPath(&amp;S);                return true;            }            curstep++;        } else {            if(!StackEmpty(S)) {                // 从栈中循环谈栈                Pop(&amp;S, &amp;curpos);                direction = Pass(curpos);                if(direction) {                    curpos.direction = direction - 1;                }                // 该块标识为不能通过                MakePrint(curpos, 3);                /////////////////////                draw(curpos.x, curpos.y, 4);                imshow(&quot;Maze&quot;, mat);                waitKey(wait_key);                while(!StackEmpty(S) &amp;&amp; curpos.direction == 5) {                    Pop(&amp;S, &amp;curpos);                    // 该块标识为不能通过                    MakePrint(curpos, 3);                }                if(curpos.direction &lt;= 4 &amp;&amp; Pass(curpos)) {                    curpos.direction++;                    Push(&amp;S, curpos);                    draw(curpos.x, curpos.y, 3);                    imshow(&quot;Maze&quot;, mat);                    waitKey(wait_key);                    NextPos(&amp;curpos, curpos.direction);                    Push(&amp;S, curpos);                    MakePrint(curpos, 2);                    draw(curpos.x, curpos.y, 3);                    imshow(&quot;Maze&quot;, mat);                    waitKey(wait_key);                    if(curpos.x == end.x &amp;&amp; curpos.y == end.y) {                        PrintPath(&amp;S);                        return true;                    }                }            }        }    } while(!StackEmpty(S));    return false;}int Pass(SElemType pos){    // 右    if(pos.y+1 &lt;= n-1 &amp;&amp; maze[pos.x][pos.y+1] == 0) {        printf(&quot;right\n&quot;);        return 1;    }    // 下    // attention    if(pos.x+1 &lt;= n-1 &amp;&amp; maze[pos.x+1][pos.y] == 0) {        printf(&quot;down\n&quot;);        return 2;    }    // 左    if(pos.y-1 &gt;= 1 &amp;&amp; maze[pos.x][pos.y-1] == 0) {        printf(&quot;left\n&quot;);        return 3;    }    // 上    if(pos.x-1 &gt;= 1 &amp;&amp; maze[pos.x-1][pos.y] == 0) {        printf(&quot;up\n&quot;);        return 4;    }    printf(&quot;No way!\n&quot;);    return 0;}bool StackEmpty(SqStack S) {    if(S.top == S.base)        return true;    else        return false;}// 1、2、3、4对应的搜索顺序分别为右、下、左、上void NextPos(SElemType* curpos, int direction) {    switch(direction) {        case 1: {            curpos-&gt;y++;            break;        }        case 2: {            curpos-&gt;x++;            break;        }        case 3: {            curpos-&gt;y--;            break;        }        case 4: {            curpos-&gt;x--;            break;        }    }}// 留下标记void MakePrint(SElemType e, int print){    maze[e.x][e.y] = print;}</code></pre><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="/5/maze.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java类实现卡牌操作</title>
      <link href="/4.html"/>
      <url>/4.html</url>
      
        <content type="html"><![CDATA[<h1 id="完成一个“卡牌操作”的类"><a href="#完成一个“卡牌操作”的类" class="headerlink" title="完成一个“卡牌操作”的类"></a>完成一个“卡牌操作”的类</h1><p>题目要求：</p><p>1.以面向对象方式写一个“卡牌操作”类：CardOperator</p><p>2.具有以下功能（类似扑克的功能）：</p><ul><li><p>功能1：初始化卡牌，initialCards（）</p></li><li><p>功能2：显示卡牌，showCards（）</p></li><li><p>功能3：洗牌（将牌打乱），shuffleCards（）</p></li><li><p>功能4：理牌（重新排序），rankCards（）</p></li></ul><p>3.写一个主控程序：MainProcess类（包含main函数）</p><ul><li><p>调用CardOperator完成各种卡牌操作</p></li><li><p>MainProcess类如下图（直接copy即可）</p></li></ul><p><img src="/4/MainProcess.png" alt></p><ul><li>输出结果如下图所示</li></ul><p><img src="/4/1.png" alt></p><p><img src="/4/2.png" alt></p><p><img src="/4/3.png" alt></p><h3 id="CardOperator-java"><a href="#CardOperator-java" class="headerlink" title="CardOperator.java"></a>CardOperator.java</h3><pre><code>package cn.itcast.train.demo2;public class CardOperater {    private static int numPerCards = 52;    //  private int cards_num;    //  private int[][] cards;    public int[][] CardOperater(int userInputCardsNum) {        int[][] cards = new int[userInputCardsNum][numPerCards];        for (int i = 0; i &lt; userInputCardsNum; i++) {            cards[i] = initialCards();        }        return cards;    }    public static int[] initialCards() {        int[] cardArray = new int[52];        for (int i = 0; i &lt; cardArray.length; i++) {            cardArray[i] = i;        }        return cardArray;    }    public static void showCards(int[][] cardArrays) {        int cardTypeNumber;        int cardValueNumber;        int count = 0;        String cardString;        for (int i = 0; i &lt; cardArrays.length; i++) {            System.out.printf(&quot;第%d副卡牌\n&quot;, i + 1);            for (int j = 0; j &lt; numPerCards; j++) {                cardTypeNumber = cardArrays[i][j] / 13;                cardValueNumber = cardArrays[i][j] % 13;                cardString = judge(cardTypeNumber, cardValueNumber);                if (count % 13 == 12)                    System.out.println(cardString);                else {                    System.out.printf(&quot;%s &quot;, cardString);                }                count++;            }            System.out.println();        }    }    private static String judge(int cardTypeNumber, int cardValueNumber) {        String cardType = &quot;&quot;;        String cardValue = &quot;&quot;;        switch (cardTypeNumber) {            case 0 -&gt; {                cardType = &quot;黑桃&quot;;            }            case 1 -&gt; {                cardType = &quot;红桃&quot;;            }            case 2 -&gt; {                cardType = &quot;方片&quot;;            }            case 3 -&gt; {                cardType = &quot;梅花&quot;;            }            default -&gt; {                System.out.println(&quot;初始化错误&quot;);                System.exit(2);            }        }        switch (cardValueNumber) {            case 0 -&gt; {                cardValue = &quot;A&quot;;            }            case 10 -&gt; {                cardValue = &quot;Jack&quot;;            }            case 11 -&gt; {                cardValue = &quot;Queen&quot;;            }            case 12 -&gt; {                cardValue = &quot;King&quot;;            }            default -&gt; {                cardValue = String.valueOf(cardValueNumber + 1);            }        }        return cardType + cardValue;    }    public int[][] shuffleCards(int[][] cardArray) {        for (int i = 0; i &lt; cardArray.length; i++) {            for (int j = 0;j &lt; numPerCards; j++) {                int index = (int) (Math.random() * (numPerCards));                int tmp = cardArray[i][j];                cardArray[i][j] = cardArray[i][index];                cardArray[i][index] = tmp;            }        }        return cardArray;    }    public static int[][] rankCards(int[][] cardArray) {        for (int[] ints : cardArray) {            qSort(ints, 0, ints.length - 1);        }        return cardArray;    }    public static void qSort(int[] array, int p, int r) {        int q;        if (p &lt; r) {            q = partition(array, p, r);            qSort(array, p, q - 1);            qSort(array, q + 1, r);        }    }    public static int partition(int[] array, int p, int r) {        int x = array[r];        int i = p - 1; // 指向的是比主元素小的位置        int temp;        for (int j=p;j&lt;=r-1;j++) {            if (array[j] &lt;= x) {                i++;                temp = array[i];                array[i] = array[j];                array[j] = temp;            }        }        temp = array[i+1];        array[i+1] = array[r];        array[r] = temp;        return i + 1;    }}</code></pre><h3 id="MainProcess-java"><a href="#MainProcess-java" class="headerlink" title="MainProcess.java"></a>MainProcess.java</h3><pre><code>package cn.itcast.train.demo2;public class MainProcess {    public static void main(String[] args) {        int[][] cards;        int[][] shuffledCards;        int[][] rankedCards;        CardOperater co = new CardOperater();        int userInputCardsNum = 3;        cards = co.CardOperater(userInputCardsNum);        System.out.printf(&quot;初始化%d副卡牌\n&quot;, userInputCardsNum);        CardOperater.showCards(cards);        System.out.println(&quot;打乱卡牌&quot;);        shuffledCards = co.shuffleCards(cards);        CardOperater.showCards(shuffledCards);        System.out.println(&quot;重新洗牌&quot;);        rankedCards = CardOperater.rankCards(shuffledCards);        CardOperater.showCards(rankedCards);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序和二分查找</title>
      <link href="/3.html"/>
      <url>/3.html</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>Java二分查找的实现和递归实现快速排序。</p><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p><strong>题目描述：</strong></p><p>输入整数n(n&gt;0&amp;&amp;n&lt;=100)，表示数组的长度</p><p> 输入n个正整数（递增），作为数组元素</p><p> 输入1个正整数，作为要查找的元素</p><p> 输出：利用二分查找输出要查找的元素在数组中的下标位置，若没有这个数则输出no </p><p>二分查找： 又叫折半查找，要求待查找的序列有序。每次取中间位置的值与待查关键字比较，如果中间位置的值比待查关键字大，则在前半部分循环这个查找的过程，如果中间位置的值比待查关键字小，则在后半部分循环这个查找的过程。直到查找到了为止，否则序列中没有待查的关键字。</p><pre><code>import java.util.Scanner;public class binarySearch {    public static void main(String[] args) {        int len;        int[] array = new int[100];        int toSearch;        int curpos;        boolean flag;        int low;        int high;        Scanner in = new Scanner(System.in);        while(in.hasNext()) {            len = in.nextInt();            for(int i=0; i&lt;len; i++) {                array[i] = in.nextInt();            }            toSearch = in.nextInt();            flag = false;            low = 0;            high = len - 1;            curpos = (low + high) / 2;            while(low &lt;= high) {                if(array[curpos] &gt; toSearch) {                    high = curpos - 1;                } else if (array[curpos] &lt; toSearch) {                    low = curpos + 1;                } else {                    flag = true;                    break;                }                curpos = (low + high) / 2;            }            if(!flag) {                System.out.println(&quot;no&quot;);                continue;            }            System.out.println(curpos);        }    }}</code></pre><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p><strong>题目描述</strong></p><p>快速排序是常用排序算法，请参考以下资料实现对一组数组的升序快速排序 </p><p>思路： </p><ol><li><p>数组中选择一个数作为基准点（可以选第一个元素，也可以任意选择） </p></li><li><p>将所有大于基准点的放在基准点右侧，所有小于基准点的放在其左侧 </p></li><li><p>针对基准点左侧和右侧的区间，重复步骤1和2，直到各区间只有一个数 </p><p>参考网址：<a href="http://tools.jb51.net/aideddesign/paixu_ys" target="_blank" rel="noopener">http://tools.jb51.net/aideddesign/paixu_ys</a></p></li></ol><pre><code>import java.util.Scanner;public class quickSort {    public static void main(String[] args) {        Scanner in = new Scanner(System.in);        while(in.hasNext()) {            int len = in.nextInt();            int[] array = new int[len];            for (int i=0;i&lt;len;i++) {                array[i] = in.nextInt();            }            qSort(array, 0, array.length - 1);            for (int j=0;j&lt;len;j++) {                System.out.printf(&quot;%d &quot;, array[j]);            }            System.out.println();        }    }    public static void qSort(int[] array, int p, int r) {        int q;        if (p &lt; r) {            q = partition(array, p, r);            qSort(array, p, q - 1);            qSort(array, q + 1, r);        }    }    public static int partition(int[] array, int p, int r) {        int x = array[r];        int i = p - 1; // 指向的是比主元素小的位置        int temp;        for (int j=p;j&lt;=r-1;j++) {            if (array[j] &lt;= x) {                i++;                temp = array[i];                array[i] = array[j];                array[j] = temp;            }        }        temp = array[i+1];        array[i+1] = array[r];        array[r] = temp;        return i + 1;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker部署Python-Flask后端</title>
      <link href="/2.html"/>
      <url>/2.html</url>
      
        <content type="html"><![CDATA[<h1 id="docker环境部署入门"><a href="#docker环境部署入门" class="headerlink" title="docker环境部署入门"></a>docker环境部署入门</h1><p>最近导师要求将自己的后端环境打包成一个容器上传到阿里云服务器上面。要装成容器的原因是服务器上面的配置环境是很复杂的，为此就要单独配置一个环境来满足要求。</p><h3 id="Dockerfile文件"><a href="#Dockerfile文件" class="headerlink" title="Dockerfile文件"></a>Dockerfile文件</h3><pre><code># Docker image for flask python run# VERSION 1.0# Author: PSH# 基础镜像使用python:3.7FROM python:3.7# 更换镜像源RUN echo &quot;&quot;&gt;sources.list  &amp;&amp; \    echo &quot;deb http://mirrors.163.com/ubuntu/ artful main restricted universe multiverse&quot;&gt;&gt;sources.list  &amp;&amp; \    echo &quot;deb http://mirrors.163.com/ubuntu/ artful-security main restricted universe multiverse&quot;&gt;&gt;sources.list  &amp;&amp; \    echo &quot;deb http://mirrors.163.com/ubuntu/ artful-updates main restricted universe multiverse&quot;&gt;&gt;sources.list  &amp;&amp; \    echo &quot;deb http://mirrors.163.com/ubuntu/ artful-proposed main restricted universe multiverse&quot;&gt;&gt;sources.list  &amp;&amp; \    echo &quot;deb http://mirrors.163.com/ubuntu/ artful-backports main restricted universe multiverse&quot;&gt;&gt;sources.list  &amp;&amp; \    echo &quot;deb-src http://mirrors.163.com/ubuntu/ artful main restricted universe multiverse&quot;&gt;&gt;sources.list  &amp;&amp; \    echo &quot;deb-src http://mirrors.163.com/ubuntu/ artful-security main restricted universe multiverse&quot;&gt;&gt;sources.list  &amp;&amp; \    echo &quot;deb-src http://mirrors.163.com/ubuntu/ artful-updates main restricted universe multiverse&quot;&gt;&gt;sources.list  &amp;&amp; \    echo &quot;deb-src http://mirrors.163.com/ubuntu/ artful-proposed main restricted universe multiverse&quot;&gt;&gt;sources.list  &amp;&amp; \    echo &quot;deb-src http://mirrors.163.com/ubuntu/ artful-backports main restricted universe multiverse&quot;&gt;&gt;sources.list# 更新安装源RUN sed -i s@/deb.debian.org/@/mirrors.aliyun.com/@g /etc/apt/sources.list \    &amp;&amp; apt-get clean \    &amp;&amp; apt-get update# 将服务器 requirements.txt和app.py 文件复制到 容器 /目录下COPY requirements.txt /COPY app.py /# 指定容器工作目录为 /WORKDIR /# 安装 项目依赖RUN pip install --user -r requirements.txt -i https://mirrors.aliyun.com/pypi/simple# 安装gcc编译器RUN apt-get -y install gcc mono-mcs &amp;&amp; \    rm -rf /var/lib/apt/lists/*# 下载金融量化工具TA-LibRUN wget http://prdownloads.sourceforge.net/ta-lib/ta-lib-0.4.0-src.tar.gz  &amp;&amp; \    tar -xvf ta-lib-0.4.0-src.tar.gz  &amp;&amp; \    cd ta-lib  &amp;&amp; \    ./configure --prefix=/usr &amp;&amp; \    make &amp;&amp; \    make install  &amp;&amp; \    pip install TA-Lib# 安装vim和lsof工具并更新包RUN apt-get update &amp;&amp; \    apt-get install apt-file &amp;&amp; \    apt-file update &amp;&amp; \    apt-get install vim &amp;&amp; \    apt-get install lsofENTRYPOINT [&quot;python&quot;]CMD [&quot;app.py&quot;]# 编译# docker build -t quant/service .# run，将宿主机的5000端口映射到docker的5050端口# docker run -it -d --name quant -p 5000:5050 quant/service</code></pre><h3 id="app-py文件"><a href="#app-py文件" class="headerlink" title="app.py文件"></a>app.py文件</h3><pre><code># encoding:utf-8from flask import Flask, request, jsonifyfrom flask_cors import CORSapp = Flask(__name__)CORS(app, resources=r&#39;/*&#39;)  # 注册CORS, &quot;/*&quot; 允许访问所有api@app.route(&#39;/&#39;, methods=[&quot;GET&quot;, &quot;POST&quot;])def motion_index():    return &quot;Hello Docker!&quot;if __name__ == &#39;__main__&#39;:    app.run(debug=True, host=&quot;0.0.0.0&quot;, port=5050)</code></pre><p>注意，由于是将文件在docker中的linux环境运行，所以端口号不是<strong>127.0.0.1</strong>而是<strong>0.0.0.0</strong>。</p><p>这样的话，在浏览器的url中输入</p><pre><code>localhost:5000</code></pre><p>就可以访问到数据了</p><h2 id="docker启动错误解决"><a href="#docker启动错误解决" class="headerlink" title="docker启动错误解决"></a>docker启动错误解决</h2><p><img src="/2/error1.png" alt></p><p><img src="/2/error2.png" alt></p><p>以管理员方式打开CMD, 运行<code>netsh winsock reset</code> 后, 再次启动Docker就可以了。</p><p><img src="/2/3.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github + Hexo 搭建个人博客超详细教程</title>
      <link href="/1.html"/>
      <url>/1.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/01.png" alt></p><p><font color="magenta" size="4"><strong>在搭建过程中遇到问题欢迎来骚扰我哈！<font color="red" size="4"> V：weixin_psh263，QQ:1494121350</font>，如果觉得有帮助的话不介意打赏一杯奶茶哟~</strong></font></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>作为一名计算机爱好者，摸索了一周搭建出自己的博客。目前只学    习了c语言，没有任何前端知识和网站开发经验，总的来说，算不上很难，     但也要费些心思。网上各类教程应有尽有，只要肯摸索，还是水到渠成的事。另外，写下这篇文章，记录下自己的经验，给需要的朋友，祝你早日拥有自己的博客！</p></li><li><p>搭建博客的初衷是希望用博客记录下自己的学习过程，帮助自己复习，分享一部分不成熟的思考，敦促自己把既定的目标完成。</p></li><li><p><strong>为什么要搭建自己的博客？可以看看这三篇文章：</strong></p></li></ul><p><a href="http://mindhacks.cn/2009/02/15/why-you-should-start-blogging-now/" title="为什么你应该（从现在开始就）写博客" target="_blank" rel="noopener">《为什么你应该（从现在开始就）写博客》</a>   (By 刘未鹏 | Mind Hacks)</p><p><a href="https://www.zhihu.com/question/19916345" title="为什么要自建博客？" target="_blank" rel="noopener">《为什么要自建博客？》</a>   (By 知乎)</p><p><a href="https://www.cnblogs.com/jhzhu/p/3893297.html" title="我为什么写博客" target="_blank" rel="noopener">《我为什么写博客》</a> （By 知明所以）</p><p>我们需要知道搭建博客要用到的框架。<font color="red" size="3">Hexo</font>是高效的静态站点生成框架，它基于<font color="red" size="3">Node.js</font>。我们使用<font color="red" size="3">MarkDown</font>在本地编辑我们的博客文章，通过<font color="red" size="3">Hexo</font>生成静态页面，再用两条命令即可部署到我们的网站。无需关心网页源代码的具体细节，我们只需要用心写好自己的博客内容就行。</p><h2 id="本文目录"><a href="#本文目录" class="headerlink" title="本文目录"></a>本文目录</h2><ul><li><strong>快速搭建</strong></li><li>安装<font color="red" size="3">Node.js</font></li><li>添加国内镜像</li><li>安装<font color="red" size="3">Git </font></li><li>注册<font color="red" size="3">Github</font>账号</li><li>创建<font color="red" size="3">Git</font>仓库</li><li>安装<font color="red" size="3">Hexo</font> </li><li>配置本地<font color="red" size="3">Hexo</font></li><li>连接<font color="red" size="3">Github</font>与本地 </li><li>写文章、发布文章 </li><li><font color="red" size="3">MarkDown</font>文章编辑器说明</li><li>配置个性化域名</li><li>更换自己喜欢的<font color="red" size="3">Hexo</font>主题</li><li>我的博客源代码</li><li>结语</li></ul><hr><h1 id="快速搭建"><a href="#快速搭建" class="headerlink" title="快速搭建"></a>快速搭建</h1><p>有的朋友可能不想去折腾，自定义主题也比较麻烦，亦或有尝试几次搭建却失败，那就可以看这部分。快速搭建可以帮助我们更快搭建出自己的博客，优点是别人博客有的东西你都有，就跟复制差不多；缺点是博客里的配置信息都是别人的，不过不要紧，稍稍改改配置就可以。</p><p>在这里以我的博客为例。</p><h2 id="一、下载博客源代码"><a href="#一、下载博客源代码" class="headerlink" title="一、下载博客源代码"></a>一、下载博客源代码</h2><p>大家可以直接素质二连，<font color="red" size="3">Star&amp;Fork</font>参考博客源代码：<a href="https://github.com/MUYIio/hexo-themes-matery" target="_blank" rel="noopener">https://github.com/MUYIio/hexo-themes-matery</a>，这里我给出两种下载方法：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/03.png" alt></p><p><strong>第一种</strong>：直接<font color="red" size="3">DownLoad</font>，下载到本地就可以。（<strong>不推荐</strong>）</p><p><strong>第二种</strong>：如果你已经安装了<a href="https://git-scm.com/download/win" title="Git" target="_blank" rel="noopener">Git</a>，就可以右键单击<font color="red" size="3">Come Bash Here</font>运行</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> clone git@github.com:MUYIio/hexo-themes-matery.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>将所有文件下载到本地，这个复杂一点。</p><h2 id="二、修改博客文档配置"><a href="#二、修改博客文档配置" class="headerlink" title="二、修改博客文档配置"></a>二、修改博客文档配置</h2><p>首先将我们下载的博客源代码解压，然后修改主要配置：</p><ul><li>根目录配置文件<font color="red" size="3">_config.yml</font>和主题目录配置文件<font color="red" size="3">_config.yml</font>中修改个人信息。</li><li>根目录配置文件中修改<font color="red" size="3">deploy</font>一栏的<font color="red" size="3">repository</font>。</li><li>根目录配置文件中修改<font color="red" size="3">baidu_url_submit</font>一栏的<font color="red" size="3">token</font>。</li><li>主题配置文件中修改<font color="red" size="3">gitalk</font>一栏，修改方法见正文。</li></ul><p>我给出的是博客比较明显的几个地方，先修改这几个地方，其它的可以自己慢慢摸索修改。</p><p>最后一步，<strong>本地的运行环境还是需要搭建好的</strong>，跟着下文操作到连接Github与本地，环境就算是搭建完成。</p><p><strong>本地环境搭建好之后会生成的文件：</strong></p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/35.png" alt></p><p>然后直接把<font color="red" size="3">Hexo</font>文件夹里面的文件删掉，把我的源代码的文件全部移动过来，就是这样了：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/37.png" alt></p><p>然后在<font color="red" size="3">Hexo</font>文件夹下右键单击鼠标，点击 <font color="red" size="3">Git Bash Here</font>点击输入以下命令上传就可以了：</p><pre><code>hexo cleanhexo ghexo d</code></pre><h1 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h1><p>了解一下什么是<font color="red" size="3">Node.js</font>：</p><blockquote><p><font color="red" size="3">Node.js</font>就是一个用于创建服务器端应用程序的运行系统，它可以轻松构建网络或其他事件驱动的应用程序服务器。</p></blockquote><p>需要用到的命令：</p><pre><code>$ git --version$ node -v$ npm -v</code></pre><p><a href="https://nodejs.org/en/download/" title="Node.js" target="_blank" rel="noopener">点击此处</a>进入<font color="red" size="3">Node.js</font>官网下载相应版本即可，安装时选项全部默认，一路点击<font color="red" size="3">Next</font>。</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/04.png" alt></p><p>检验是否安装成功：<br>按<font color="red" size="3">Win+R</font>打开命令提示符，输入<font color="red" size="3">node -v</font>和<font color="red" size="3">npm -v</font>，如果出现版本号，那么就安装成功了。</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/05.png" alt></p><h1 id="添加国内镜像"><a href="#添加国内镜像" class="headerlink" title="添加国内镜像"></a>添加国内镜像</h1><p>这里我们使用阿里的国内镜像进行加速，按Win+R打开命令提示符输入：</p><pre><code>npm config set registry https://registry.npm.taobao.org</code></pre><h1 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h1><blockquote><p><font color="red" size="3">Git</font>是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理，帮助我们把本地网页上传到<font color="red" size="3">Github</font>。</p></blockquote><p><a href="https://git-scm.com/download/win" title="Git" target="_blank" rel="noopener">点击此处</a>进入Git官网下载相应版本，默认安装即可。</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/005.png" alt></p><p>参考资料：<a href="https://www.cnblogs.com/jytx/p/5602927.html" title="如何在windows下安装GIT" target="_blank" rel="noopener">《如何在windows下安装GIT》</a> (By 俊雨廷休)</p><p>检验是否安装成功：</p><p>安装完成后在命令提示符中输入<font color="red" size="3">git –version</font>验证是否安装成功</p><pre><code>git --version</code></pre><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/06.png" alt></p><h1 id="注册Github账号"><a href="#注册Github账号" class="headerlink" title="注册Github账号"></a>注册Github账号</h1><p><font color="red" size="3">Github</font>作为全球最大的开源社区，相信朋友们都已经有了吧，如果没有，<a href="https://github.com/" title="Github" target="_blank" rel="noopener">点击此处</a>进入<font color="red" size="3">Github</font>官网点击 <font color="red" size="3">Sign Up </font>注册账户。</p><h1 id="创建git仓库"><a href="#创建git仓库" class="headerlink" title="创建git仓库"></a>创建git仓库</h1><p>登录<font color="red" size="3">Github</font>创建一个仓库</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/07.png" alt></p><p>如下图所示，<strong>输入自己的项目名字，后面一定要加<font color="red" size="3">.github.io</font>后缀，<font color="red" size="3">README</font>初始化也要勾上。名称一定要和你的<font color="red" size="3">Github</font>名字完全一样，比如你<font color="red" size="3">github</font>名字叫<font color="red" size="3">A</font>，那么仓库名字一定要是<font color="red" size="3">A.github.io</font>。</strong></p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/08.png" alt></p><p>选择一个自己喜欢的主题：<br>在上面创建的仓库里面点击<font color="red" size="3">Settings</font>（不是头像下面那个<font color="red" size="3">Settings</font>），向下拉到最后有个<font color="red" size="3">GitHub Pages</font>，点击<font color="red" size="3">Choose a theme</font>选择一个主题。然后等一会儿，再回到<font color="red" size="3">GitHub Pages</font>，就可以预览效果啦。</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/09.png" alt></p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/10.png" alt></p><h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><blockquote><p><font color="red" size="3">Hexo</font>是一款基于<font color="red" size="3">Node.js</font>的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在<font color="red" size="3">GitHub</font>和<font color="red" size="3">Heroku</font>上，是搭建博客的首选框架。</p></blockquote><p>选择一个磁盘，新建一个文件夹用来存放博客文件。比如我的<font color="red" size="3">（C/panakot Blog）</font>，在该文件夹下右键单击鼠标，点击<font color="red" size="3"> Git Bash Here</font>，输入以下<font color="red" size="3"> npm </font>命令即可安装</p><pre><code>$ npm install hexo-cli -g</code></pre><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/11.png" alt></p><p>输入<font color="red" size="3">hexo -v</font>即可检验是否安装成功，我这里就不演示了。</p><h1 id="配置本地hexo"><a href="#配置本地hexo" class="headerlink" title="配置本地hexo"></a>配置本地hexo</h1><p>还是在刚才新建的文件夹下再新建一个<font color="red" size="3">Hexo</font>文件夹，比如我的<font color="red" size="3">（C/panakot Blog/Hexo）</font>，在<font color="red" size="3">Hexo</font>文件夹下右键单击鼠标，点击<font color="red" size="3"> Git Bash Here</font>，依次输入以下<font color="red" size="3"> npm </font>命令即可初始化。</p><pre><code>hexo initnpm install</code></pre><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/12.png" alt></p><p>初始化成功生成的文件：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/13.png" alt></p><p>接着我们输入<font color="red" size="3">hexo g</font>生成静态网页，然后输入<font color="red" size="3">hexo s</font>打开本地服务器，然后浏览器打开<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>，就可以预览我们的博客啦，如图：</p><p>显示以下信息说明操作正确：</p><p><code>INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop.</code></p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/14.png" alt></p><p>按<font color="red" size="3">ctrl+c</font>关闭本地服务器。</p><p><strong>我们以后常用到的<font color="red" size="3">Hexo</font>命令：</strong></p><ul><li><p><font color="red" size="3">hexo s</font>等价于 <font color="red" size="3">hexo server</font>  #<font color="red" size="3">Hexo</font> 会监视文件变动并自动更新，除修改站点配置文件外,无须重启服务器,直接刷新网页即可生效。</p></li><li><p><font color="red" size="3">hexo g</font> 等价于 <font color="red" size="3">hexo generate</font>  #生成静态网页 (执行 $ <font color="red" size="3">hexo g</font>后会在站点根目录下生成<font color="red" size="3">public</font>文件夹,<font color="red" size="3"> hexo</font>会将”<font color="red" size="3">/blog/source/</font>“ 下面的<font color="red" size="3">.md</font>后缀的文件编译为<font color="red" size="3">.html</font>后缀的文件,存放在”<font color="red" size="3">/blog/public/ </font>“ 路径下)</p></li><li><p><font color="red" size="3">hexo d </font>等价于 <font color="red" size="3">hexo deploy</font>  #将本地数据部署到远端服务器(如<font color="red" size="3">github</font>)</p></li><li><p><font color="red" size="3">hexo clean </font> #清除缓存 ,网页正常情况下可以忽略此条命令,执行该指令后,会删掉站点根目录下的<font color="red" size="3">public</font>文件夹</p></li></ul><h1 id="连接Github与本地"><a href="#连接Github与本地" class="headerlink" title="连接Github与本地"></a>连接Github与本地</h1><h2 id="一、生成密钥"><a href="#一、生成密钥" class="headerlink" title="一、生成密钥"></a>一、生成密钥</h2><p>右键单击鼠标，点击 <font color="red" size="3">Git Bash Here</font>输入以下命令：</p><pre><code>git config --global user.name &quot;Name&quot;git config --global user.email &quot;Email&quot;</code></pre><p><strong><font color="red" size="3">Name</font>和<font color="red" size="3">Email</font>是我们注册<font color="red" size="3">Github</font>时的用户名和邮箱。</strong></p><p>然后生成密钥：</p><pre><code>ssh-keygen -t rsa -C &quot;Email&quot;</code></pre><p><strong><font color="red" size="3">Email</font>是我们注册<font color="red" size="3">Github</font>时的邮箱</strong></p><p>然后会出现：</p><pre><code>Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/you/.ssh/id_rsa)://到这里可以直接回车将密钥按默认文件进行存储</code></pre><p>回车之后：</p><pre><code>Enter passphrase (empty for no passphrase)://这里是要你输入密码，其实不需要输什么密码，直接回车就行Enter same passphrase again:</code></pre><p>接下来会有：</p><pre><code>Your identification has been saved in /c/Users/you/.ssh/id_rsa.Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub.The key fingerprint is:这里是各种字母数字组成的字符串，结尾是你的邮箱The key&#39;s randomart image is:这里也是各种字母数字符号组成的字符串</code></pre><p>现在密钥已经生成，一般存放在<font color="red" size="3">（/c/Users/you/.ssh/id_rsa.pub.）</font>，我们运行下面的命令将密钥复制为粘贴板：</p><pre><code> clip &lt; ~/.ssh/id_rsa.pub</code></pre><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/15.png" alt></p><h2 id="二、连接Github"><a href="#二、连接Github" class="headerlink" title="二、连接Github"></a>二、连接Github</h2><p>在<font color="red" size="3">Github</font>头像下面点击<font color="red" size="3">Settings</font>，再点击<font color="red" size="3">SSH and GPG keys</font>，新建一个<font color="red" size="3">SSH</font>，名字任意。</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/16.png" alt></p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/17.png" alt></p><p>然后将刚才复制的密钥添加就可以了，像这样：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/18.png" alt></p><p><strong>本地连接Github</strong></p><p>右键单击鼠标，点击<font color="red" size="3"> Git Bash Here</font>输入以下命令，如果如下图所示，出现你的用户名，那就成功了</p><pre><code>ssh -T git@github.com//注意不要做任何修改</code></pre><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/19.png" alt></p><p>用记事本打开博客根目录下的<font color="red" size="3">_config.yml</font>文件，这是博客的配置文件，我们需要修改一下才能连接<font color="red" size="3">Github</font>。</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/20.png" alt></p><p>修改最后一行的配置：</p><pre><code># Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type:</code></pre><p>改为：</p><pre><code># Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  repository: git@github.com:panakot/panakot.github.io.git  branch: master</code></pre><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/21.png" alt></p><p>切记：</p><ul><li><strong><font color="red" size="3">repository</font>修改为你自己的<font color="red" size="3">github</font>项目地址</strong>。</li><li><strong>每一个冒号后面都有一个空格。</strong></li></ul><h1 id="写文章、发布文章"><a href="#写文章、发布文章" class="headerlink" title="写文章、发布文章"></a>写文章、发布文章</h1><p>首先在博客根目录下右键打开<font color="red" size="3">Git Bash Here</font>输入以下命令，安装一个扩展.</p><pre><code>npm i hexo-deployer-git</code></pre><p>然后输入下面的命令，新建一篇文章。</p><pre><code>hexo new post &quot;article title&quot;</code></pre><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/22.png" alt></p><p>然后打开<font color="red" size="3">C:\panakot Blog\Hexo\source_posts</font>的目录，可以发现下面多了一个文件夹和一个<font color="red" size="3">.md</font>文件，一个用来存放你的图片等数据，另一个就是你的文章文件啦。</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/23.png" alt></p><p>编写完<font color="red" size="3">markdown</font>文件后，根目录下右键打开<font color="red" size="3">Git Bash Here</font>输入<font color="red" size="3">hexo g</font>生成静态网页，然后输入<font color="red" size="3">hexo s</font>可以本地预览效果，最后输入<font color="red" size="3">hexo d</font>上传到<font color="red" size="3">github</font>上。</p><p>你的博客地址：<font color="red" size="3">https://你的用户名.github.io</font>，比如我的是：<a href="https://muyiio.github.io" target="_blank" rel="noopener">https://muyiio.github.io</a>，现在每个人都可以通过此链接访问你的博客</p><h1 id="MarkDown文章编辑器说明"><a href="#MarkDown文章编辑器说明" class="headerlink" title="MarkDown文章编辑器说明"></a>MarkDown文章编辑器说明</h1><blockquote><p>前面我们提到了使用<font color="red" size="3">MarkDown</font>编辑我们的博客文章。<font color="red" size="3"> Markdown</font> 是<font color="red" size="3"> 2004</font> 年由 <font color="red" size="3">John Gruberis </font>设计和开发的纯文本格式的语法，非常的简单实用，常用的标记符号屈指可数，几分钟即可学会，<font color="red" size="3"> .md </font>文件可以使用支持 <font color="red" size="3">Markdown </font>语法的编辑器编辑，然后将写好的文章<font color="red" size="3">（.md文件）</font>保存到<font color="red" size="3"> \Hexo\source_posts </font>文件夹下即可。</p></blockquote><p> <font color="red" size="3">Windows </font>上推荐使用 <font color="red" size="3">MarkdownPad2 </font>或者<font color="red" size="3">小书匠</font>编辑器，<font color="red" size="3">macOS </font>上使用<font color="red" size="3"> Mou</font> 编辑器，<font color="red" size="3">Linux </font>上使用 <font color="red" size="3">Remarkable</font> 编辑器，<font color="red" size="3">Web </font>端上使用 简书。</p><p><strong><a href="http://markdownpad.com/download.html" title="MarkDown" target="_blank" rel="noopener">点击此处</a>下载<font color="red" size="3">MarkDown</font><br>，刚使用的朋友或许不知道如何使用这个编辑器，只需要几分钟就可以掌握啦，给出以下几个我觉得不错的参考：</strong></p><p><a href="https://www.jianshu.com/p/q81RER/" title="献给写作者的 Markdown 新手指南" target="_blank" rel="noopener">《献给写作者的 Markdown 新手指南》</a> （By 简书）</p><p><a href="https://blog.csdn.net/u014061630/article/details/81359144?utm_source=app" title="Markdown语法图文全面详解" target="_blank" rel="noopener">《Markdown语法图文全面详解(10分钟学会)》</a>（By 黑暗星球）</p><p><a href="https://blog.csdn.net/witnessai1/article/details/52551362?utm_source=app" title="Markdown 语法手册 （完整整理版）" target="_blank" rel="noopener">《Markdown 语法手册 （完整整理版）》</a> （By witnessai1）</p><p><a href="https://sspai.com/post/25137" title="认识与入门 Markdown" target="_blank" rel="noopener">《认识与入门 Markdown》</a>（By Te_Lee）</p><p>写完文章记得在博客根目录<font color="red" size="3">Bash Here</font>输入<font color="red" size="3">hexo g</font>和<font color="red" size="3">hexo d</font>上传到网站。</p><h1 id="配置个性化域名"><a href="#配置个性化域名" class="headerlink" title="配置个性化域名"></a>配置个性化域名</h1><p>一顿操作下来，打开我们的博客还是：<font color="red" size="3"><a href="http://www.xxx.github.io" target="_blank" rel="noopener">www.xxx.github.io</a></font>，是不是很没有牌面？我们可以考虑购买一个专属域名，以后打开博客就是这样：<font color="red" size="3"><a href="http://www.xxx.com" target="_blank" rel="noopener">www.xxx.com</a> </font>。</p><p><a href="https://www.aliyun.com/" title="阿里云" target="_blank" rel="noopener">阿里云</a>和<a href="https://cloud.tencent.com/" title="腾讯云" target="_blank" rel="noopener">腾讯云</a>都可以，我的是腾讯云，购买域名后首先需要添加解析：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/24.png" alt></p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/25.png" alt></p><p><strong>方法一：</strong>点击添加记录，需要添加两个记录，两个记录类型都是 <font color="red" size="3">CNAME </font>，第一个主机记录为<font color="red" size="3"> @ </font>，第二个主机记录为<font color="red" size="3"> www</font>，记录值都是填你自己的博客地址（比如我的是：<font color="red" size="3">muyiio.github.io</font>），保存之后域名解析就完成了！</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/27.png" alt></p><p><strong>方法二：</strong>两个记录类型为<font color="red" size="3"> A </font>，第一个主机记录为<font color="red" size="3"> @ </font>，第二个主机记录为<font color="red" size="3"> www</font>，记录值都为博客的<font color="red" size="3"> IP</font> 地址，<font color="red" size="3">IP </font>地址可以<font color="red" size="3"> cmd</font> 中输入<font color="red" size="3"> ping</font> 你的博客地址 获得（比如我的：<font color="red" size="3">ping muyiio.github.io</font>），保存之后域名解析就完成了！</p><p>参考资料：</p><p><a href="https://blog.csdn.net/it_man/article/details/9017307" title="域名解析中A记录、CNAME、MX记录、NS记录的区别和联系" target="_blank" rel="noopener">《域名解析中A记录、CNAME、MX记录、NS记录的区别和联系》</a></p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/26.png" alt></p><p><strong>不管在哪个平台购买域名，操作都大同小异，这里说明两点</strong>：</p><blockquote><p>如果你填写的是没有<font color="red" size="3">www</font>的，比如 <font color="red" size="3">muyio.com</font>，那么无论是访问<font color="red" size="3"> <a href="https://www.muyiio.com" target="_blank" rel="noopener">https://www.muyiio.com</a> </font>还是<font color="red" size="3"> <a href="https://muyiio.com" target="_blank" rel="noopener">https://muyiio.com</a></font> ，都会自动跳转到<font color="red" size="3"> <a href="https://muyiio.com" target="_blank" rel="noopener">https://muyiio.com</a></font>。</p></blockquote><blockquote><p>如果你填写的是带<font color="red" size="3">www</font>的，比如 <font color="red" size="3"><a href="http://www.muyiio.com" target="_blank" rel="noopener">www.muyiio.com</a> </font>，那么无论是访问 <font color="red" size="3"><a href="https://www.muyiio.com" target="_blank" rel="noopener">https://www.muyiio.com</a></font> 还是 <font color="red" size="3"><a href="https://muyiio.com" target="_blank" rel="noopener">https://muyiio.com</a> </font>，都会自动跳转到 <font color="red" size="3"><a href="http://www.imuyiio.com" target="_blank" rel="noopener">http://www.imuyiio.com</a></font>。</p></blockquote><p>然后打开你的<font color="red" size="3">github</font>博客项目，点击settings，拉到下面<font color="red" size="3">Custom domain</font>处，填上你自己的域名，保存就可以了。</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/28.png" alt></p><p>现在我们的项目根目录应该会出现一个名为<font color="red" size="3">CNAME</font>的文件了。如果没有的话，打开你本地博客<font color="red" size="3">/source</font>目录，我的是<font color="red" size="3">C:\Blog\Hexo\source</font>，新建<font color="red" size="3">CNAME</font>文件，<font color="red" size="3">（注意不要加.txt，没有任何后缀名！）</font>。然后在里面写上你的域名，保存。最后运行<font color="red" size="3">hexo g、hexo d</font>上传到<font color="red" size="3">github</font>。</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/29.png" alt></p><p>现在就可以通过我们的个性化域名：<font color="red" size="3"><a href="http://www.xxx.com、xxx.com" target="_blank" rel="noopener">www.xxx.com、xxx.com</a></font>访问自己的博客了。</p><h1 id="更换自己喜欢的Hexo主题"><a href="#更换自己喜欢的Hexo主题" class="headerlink" title="更换自己喜欢的Hexo主题"></a>更换自己喜欢的Hexo主题</h1><p>点击进入<a href="https://hexo.io/themes/" title="Hexo主题专栏" target="_blank" rel="noopener">Hexo主题专栏</a>可以看到很多<font color="red" size="3">Hexo</font>主题：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/30.png" alt></p><p>推荐：</p><p><a href="https://blog.csdn.net/fail_perfectly/article/details/83791781?utm_source=app" title="几个好用的hexo主题" target="_blank" rel="noopener">几个好用的hexo主题</a> (By fail_perfectly)</p><p>这里我们以<a href="http://huangxuan.me/" title="Bean Tech" target="_blank" rel="noopener">Bean Tech</a>主题为例，下滑到底部我们可以看到他的<font color="red" size="3">GitHub</font>（<font color="red" size="3">有的主题是：Theme by xxx，点击那里也是进入GitHub地址</font>）：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/31.png" alt></p><p>点击进入主题的<font color="red" size="3">GitHub</font>地址：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/32.png" alt></p><p>复制该项目地址：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/33.png" alt></p><p>然后打开<font color="red" size="3"> Hexo </font>文件夹下的<font color="red" size="3"> themes</font> 目录（如：<font color="red" size="3">C:\MUYIio Blog\Hexo\themes</font>），右键<font color="red" size="3"> Git Bash Here</font>，输入以下命令：</p><pre><code>$ git clone 此处填写你刚才复制的主题地址</code></pre><p>以我们刚才复制的为例：</p><pre><code>$ git clone https://github.com/Huxpro/huxpro.github.io</code></pre><p>下载完成后即可在<font color="red" size="3"> themes </font>目录下生成 <font color="red" size="3">hexo-theme-Bean-Tech </font>文件夹，然后打开 <font color="red" size="3">Hexo</font> 文件夹下的配置文件 <font color="red" size="3">_config.yml </font>，找到关键字 <font color="red" size="3">theme</font>，修改参数为：<font color="red" size="3">theme：hexo-theme-Bean-Tech </font>（其他主题修改成相应名称即可），<strong>再次注意冒号后面有一个空格！</strong></p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/1/34.png" alt></p><p>现在我们的主题已经替换完成，将它部署到我们的博客，博客根目录下右键<font color="red" size="3"> Git Bash Here</font>，输入以下命令：</p><pre><code>hexo cleanhexo ghexo d</code></pre><p>现在访问我们的网站就可以看到主题已经更换了，但是比如网站标题，图标等都没有更换，我们博客文件中有两份主要的配置文件，名称都是 <font color="red" size="3">_config.yml</font> ，它们均是用于站点配置使用的。其中，一份位于站点根目录下（比如我的：<font color="red" size="3">C:\MUYIio Blog\Hexo_config.yml</font>），主要包含<font color="red" size="3"> Hexo</font> 本身整站的配置；另一份位于主题目录下（比如我的：<font color="red" size="3">C:\MUYIio Blog\Hexo\themes\hexo-theme-matery_config.yml</font>），这份配置由主题作者提供，主要用于配置主题相关的选项，一般<font color="red" size="3"> _config.yml </font>文件里都有相关注释，按需修改即可。</p><h1 id="我的博客源代码"><a href="#我的博客源代码" class="headerlink" title="我的博客源代码"></a>我的博客源代码</h1><p><strong>参考博客源代码地址：<a href="https://github.com/MUYIio/hexo-themes-matery" target="_blank" rel="noopener">https://github.com/MUYIio/hexo-themes-matery</a>，有心的话可以给个<font color="red" size="3">Star&amp;Fork</font>。</strong></p><p>下载源代码：git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:MUYIio/hexo-themes-matery.git</p><p>在文章开头给出了快速搭建教程，相对于自己从头开始搭建还是比较方便的，修复了很多<font color="red" size="3">Bug</font>，也添加了一些插件，下载就可以使用，可以帮你们省去个性化配置带来的很多麻烦。</p><p>主题的原地址在这里：<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">hexo-theme-matery</a>，作者把文档写得也非常的详细，还有中英文两个版本，建议可以多看几遍，在本地修改的时候轻松一些。</p><p>使用我的源代码之前本地的环境还是要搭建好，就是前面一部分。</p><table><tr><td bgcolor="orange">-----------------------------------------------------------------------------------------------------------                                                                                                                                                                                                            </td></tr></table><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>初学者可能会觉得困难，毕竟很多东西都是第一次接触，当初我也尝试了好几次才成功，不要放弃，弄错了就删掉重新来过，当你把博客搭建出来会觉得受益良多的。</p><p>文章中难免有错误的地方，有大佬发现了欢迎给我指正！有的地方解释不够详细，可以百度一下看看细节，文章中的引用以及参考资料涉及侵权请联系我删除！</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
            <tag> Hexo </tag>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware 安装 CentOS 8.1 完整教程 </title>
      <link href="/vmware-an-zhuang-centos-8-1-wan-zheng-jiao-cheng.html"/>
      <url>/vmware-an-zhuang-centos-8-1-wan-zheng-jiao-cheng.html</url>
      
        <content type="html"><![CDATA[<p>我使用的<font color="red" size="3">VMware</font>版本：<font color="red" size="3">VMware 15 Pro</font></p><p>镜像：<font color="red" size="3">CentOS 8.1</font></p><p><strong>电脑配置需求：</strong></p><ul><li><font color="red" size="3">2 GB</font> 及以上的<font color="red" size="3">RAM</font>（官方推荐至少<font color="red" size="3">4G</font>）</li><li><font color="red" size="3">2 GHz </font>或以上的 <font color="red" size="3">CPU</font></li><li><font color="red" size="3">64 </font>位 <font color="red" size="3">x86</font> 架构</li><li><font color="red" size="3">20 GB </font>及以上硬盘空间</li></ul><p><strong>关于CentOS 8.1</strong></p><ul><li>基于Linux 4.18</li><li>提供 PHP 7.2、Python 3.6、Ansible 2.8、VIM 8.0 和 Squid 4</li><li>使用网络管理器（nmcli 和 nmtui）进行网络配置，移除了网络脚本<br>通过 BaseOS 和应用流(AppStream)仓库发布.</li><li>AppStream 是对传统rpm格式的全新扩展，为一个组件同时提供多个主要版本</li><li>YUM 包管理器基于 DNF 技术，提供模块化内容支持，增强了性能，并且提供了设计良好的API用于与其他工具集成</li><li>RHEL 8提供了版本控制工具: Git 2.18, Mercurial 4.8,和 Subversion 1.10.</li></ul><blockquote><p>内核实时修补；称为 FRR 的新路由协议堆栈（支持多种 IPv4 和 IPv6 路由协议）；伯克利数据包筛选器（eBPF）的扩展版本，可帮助系统管理员解决复杂的网络问题；支持在使用设备时对 LUKS2 中的块设备进行重新加密；此外，还提供了一种用于为容器生成 SELinux 策略的新工具 udica.</p></blockquote><p><font color="red" size="3">CentOS 8</font>系列增加了许多新特性，<font color="red" size="3">CentOS 8.1</font>相当于它的第二个发行版本，我这里就不列出了，具体可以看官方文档：</p><p><a href="https://wiki.centos.org/zh/Manuals/ReleaseNotes/CentOS8.1905#A.2BbpBO43gB-" target="_blank" rel="noopener">CentOS 官网文档手册</a></p><p><a href="https://www.cnblogs.com/RXDXB/p/11660287.html" target="_blank" rel="noopener">Centos8与Centos7区别参照redhat）</a></p><h1 id="一、准备过程"><a href="#一、准备过程" class="headerlink" title="一、准备过程"></a>一、准备过程</h1><p>目前比较流行的两款虚拟机软件 <font color="red" size="3">VMware</font> 、<font color="red" size="3">VirtualBox</font>，<font color="red" size="3">VirtualBox</font>安装<font color="red" size="3">CentOS 8</font>系列目前还有很多<font color="red" size="3">Bug</font>，推荐使用<font color="red" size="3">VMware</font>。</p><p>1.安装<font color="red" size="3">VMware</font></p><p>如果你还没有安装虚拟机，进入<a href="https://www.vmware.com/products/workstation-pro/workstation-pro-evaluation.html" title="VMware" target="_blank" rel="noopener">VMware官网</a>下载相应版本安装即可：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/01.png" alt></p><p>官网下载过程可能有点慢，这里安装过程我就不赘述了。</p><p>2.下载<font color="red" size="3">CentOS 8.1</font>镜像资源</p><p>进入<a href="http://mirrors.huaweicloud.com/centos/8.1.1911/isos/x86_64/CentOS-8.1.1911-x86_64-dvd1.iso" title="CentOS" target="_blank" rel="noopener">CentOS官网</a>下载<font color="red" size="3">CentOS 8.1</font>镜像，我这里给的是在华为云的，下载速度还是可以。</p><h1 id="二、创建虚拟机"><a href="#二、创建虚拟机" class="headerlink" title="二、创建虚拟机"></a>二、创建虚拟机</h1><p>1.打开<font color="red" size="3">VMware</font>，点击创建新的虚拟机：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/02.png" alt></p><p>2.点击自定义（高级）：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/03.png" alt></p><p>3.这一步直接默认就可以：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/04.png" alt></p><p>4.选择稍后安装操作系统：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/05.png" alt></p><p>5.选择<font color="red" size="3">Linux</font>，版本选择<font color="red" size="3">Linux 4 ×64位</font>，因为<font color="red" size="3">CentOS 8</font>系列基于<font color="red" size="3"> Linux</font> 内核<font color="red" size="3"> 4.18</font>：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/06.png" alt></p><p>6.虚拟机名称随便，安装位置看自己电脑配置吧，建议安装在<font color="red" size="3">D</font>盘：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/07.png" alt></p><p>7.处理器数量根据自己电脑来配置，反正不够后面可以更改，要安装图形界面的话可以填大一点，新手就这个配置也可以了：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/08.png" alt></p><p>8.内存大小根据自己电脑适当配置，我的电脑内存<font color="red" size="3">16G</font>，所以我给它分配<font color="red" size="3">4G</font>，要安装图形界面的话可以填大一点：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/09.png" alt></p><p>9.设置虚拟机网络连接模式（<font color="red" size="3">NAT</font>）：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/10.png" alt></p><p><strong>关于网络连接模式说明：</strong></p><ul><li><p>桥接：选择桥接模式的话虚拟机和宿主机在网络上就是平级的关系，相当于连接在同一交换机上。</p></li><li><p>NAT：NAT模式就是虚拟机要联网得先通过宿主机才能和外面进行通信。</p></li><li><p>仅主机：虚拟机与宿主机直接连起来</p></li></ul><p>10.选择<font color="red" size="3">I/O</font>控制器类型，然后下一步：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/11.png" alt></p><p>11.选择磁盘类型：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/12.png" alt></p><p>12.选择创建新虚拟磁盘，然后下一步：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/13.png" alt></p><p>13.根据自己的需要分配磁盘容量，勾选将虚拟磁盘拆分成多个文件（方便以后将虚拟机拷贝到设备），然后下一步：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/14.png" alt></p><p>14.根据自己需要指定磁盘文件存储位置，我放在D盘：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/15.png" alt></p><p>15.到这里虚拟机就创建完成了，可以点击自定义硬件更改配置，点击完成创建成功：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/16.png" alt></p><h1 id="三、安装CentOS-8-1"><a href="#三、安装CentOS-8-1" class="headerlink" title="三、安装CentOS 8.1"></a>三、安装CentOS 8.1</h1><p>1.点击编辑虚拟机设置：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/17.png" alt></p><p>2.选择<font color="red" size="3">CD/DVD</font>，勾选启动时连接，再选择使用ISO映像文件，找到下载好的系统镜像文件添加进去，最后确定：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/18.png" alt></p><p>3.开启此虚拟机：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/19.png" alt></p><p>4.开启虚拟机后会出现以下界面，鼠标点进黑窗口，使用键盘方向键选择第一项，安装<font color="red" size="3">CentOS 8</font>，回车，系统开始自动安装</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/20.png" alt></p><p>5.安装完成后选择语言，根据自己情况选择，然后点击继续：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/21.png" alt></p><p>6.首先打开网络和主机名，给虚拟机连上网络：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/22.png" alt></p><p><strong>如果网络连接不上，多半是<font color="red" size="3">DHCP</font>问题，解决办法：</strong></p><p><a href="https://blog.csdn.net/suoyudong/article/details/83037670" target="_blank" rel="noopener">解决安装centos 过程中以太网连接不上网络，不能自动分配ip的问题</a> (By 索渝东)</p><p>7.点击时间和日期，设置系统时间并更改时区(打开网络时间)：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/23.png" alt></p><p>8.选择安装目的地：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/24.png" alt></p><p>9.选择自定义配置，点击完成：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/25.png" alt></p><p>10.添加磁盘分区</p><p><font color="red" size="3">Linux</font>的分区，并不像<font color="red" size="3">Windows</font>一样，分成<font color="red" size="3">C、D、E</font>等盘，介绍几个重要的分区：</p><ul><li>交换分区（swap）：交换分区和Windows的虚拟内存很像。现在内存也便宜，物理服务器的配置也高，以前的说法是一般为物理内存的2倍，现在一般情况下划分为4~8GB备用即可。我们虚拟机的内存是4GB，我们就划8GB吧。</li><li>启动分区（boot）：200MB足够了。</li><li>根分区（/）：剩余空间都给根分区吧。当然我们也可以单独划出/data分区，专门用来存储存数据，不过这里我们先不这样做，直接全部都给根分区。</li></ul><p>按照下图顺序依次进行设置：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/26.png" alt></p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/27.png" alt></p><p>11.点击完成后会弹出更改摘要页面，点击接受更改：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/28.png" alt></p><p>12.点击开始安装：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/29.png" alt></p><p>13.设置<font color="red" size="3">ROOT</font>密码：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/30.png" alt></p><p>14.点击创建用户，可以把用户设为管理员方便操作，如果密码简单就点击两次完成：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/31.png" alt></p><p>15.安装完成后点击重启电脑：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/32.png" alt></p><p>16.重启完成后点击<font color="red" size="3">LICENS INFORMATION</font>,勾选同意许可，然后点击完成：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/33.png" alt></p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/34.png" alt></p><p>17.点击结束配置：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/35.png" alt></p><p>18.来到登录界面，点击未列出，以<font color="red" size="3">root</font>登录，方便后面配置操作：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/36.png" alt></p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/37.png" alt></p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/38.png" alt></p><p>19.选择语言：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/39.png" alt></p><p>选择键盘布局：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/40.png" alt></p><p>是否打开位置服务：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/41.png" alt></p><p>然后按照需要添加账号，然后就可以进入啦：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/42.png" alt></p><p>20.关闭系统使用帮助后，来到我们的<font color="red" size="3">centos8.1</font>桌面，点击活动可以看到系统软件，第一个是内置浏览器，点击最下面可以看到系统所有软件：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/43.png" alt></p><p>21.点击右上角折叠按钮可以连接网络，打开浏览器就可以访问啦，如果不能联网，在上面已经给出解决办法：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/44.png" alt></p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/45.png" alt></p><p>22.右上角有关机按钮，点击就可以关机：</p><p><img src="https://muyiio-1300292673.cos.ap-chongqing.myqcloud.com/%E5%8D%9A%E5%AE%A2/_posts/VMware-%E5%AE%89%E8%A3%85-CentOS-8-1-%E5%AE%8C%E6%95%B4%E6%95%99%E7%A8%8B/46.png" alt></p><p>到这里，我们的<font color="red" size="3">CentOS 8 Linux</font> 就算安装完成了，其他<font color="red" size="3">CentOS 8 </font>系列发行版本安装过程类似，可作参考。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VMware </tag>
            
            <tag> CentOS </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
